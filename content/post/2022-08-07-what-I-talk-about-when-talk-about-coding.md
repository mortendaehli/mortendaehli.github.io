+++
title = "What I talk about when I talk about coding"
description = "Coding as poetry"
author = "Morten DÃ¦hli Aslesen"
date = 2022-08-07T11:37:30.000Z
tags = ["Philosophy", "Clean code"]
draft = false
+++

The fundamental idea of programming computers is to convey an idea. The idea is communicated to both machines and humans,
and is brought to life when code is executed by a machine. To bring such an idea to life you need to follow certain
rules. Most programmers are able to conform to these rules using a modern IDE and documentation.

This is where everything starts to get complicated. Should you do imperative og declarative programming? Should it be
object-oriented, functional, procedural, reactive, or whatever paradigm you can throw at a problem?

The reality is that it depends. It depends on the idea that you are trying to convey.

This is why I like to think about coding as poetry.
Poetry is composed using different **elements** such as rhythm, rhyme, visual forms and diction.
It can take the **form** of a sonnet, limerick, Haiku and a bunch of other forms.
And it can be of different **genres** such as lyric, epic or even modern slam poetry.

What elements, forms and genres you write your poetry in depends on the idea you want to convey, and the set of skills that you behold.
Some combinations are considered to better or more natural choices than others.

It is easy to measure code in therms of functional quality such as "does it execute?", "how fast is it?", "does it do what it is supposed to do?".

What is not as easy to do is to measure how well the message is conveyed, how easy is it for someone else to pick up the code, understand it, fix bugs and add new features.

The simplest way of defining this other quality is readability and how well it conveys the idea.
The code should have the prosaic quality that preferably evokes good feelings and conveys the idea in a way that you can relate and understand it.
This means that it does not have to be perfect, it does not have to be of a special form or genera. It needs to convey the idea. That's all.

    Beautiful is better than ugly.
    Explicit is better than implicit.
    Simple is better than complex.
    Complex is better than complicated.
    Flat is better than nested.
    Sparse is better than dense.
    Readability counts.
    Special cases aren't special enough to break the rules.
    Although practicality beats purity.
    Errors should never pass silently.
    Unless explicitly silenced.
    In the face of ambiguity, refuse the temptation to guess.
    There should be one-- and preferably only one --obvious way to do it.
    Although that way may not be obvious at first unless you're Dutch.
    Now is better than never.
    Although never is often better than *right* now.
    If the implementation is hard to explain, it's a bad idea.
    If the implementation is easy to explain, it may be a good idea.
    Namespaces are one honking great idea -- let's do more of those!
